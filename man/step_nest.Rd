% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_nest.R
\name{step_nest}
\alias{step_nest}
\alias{prep.step_nest}
\alias{bake.step_nest}
\title{Nest transformation}
\usage{
step_nest(
  recipe,
  ...,
  role = "predictor",
  trained = F,
  names = NULL,
  lookup_table = NULL,
  skip = F,
  id = recipes::rand_id("nest")
)

\method{prep}{step_nest}(x, training, info = NULL)

\method{bake}{step_nest}(object, new_data, ...)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the
sequence of operations for this recipe.}

\item{...}{One or more selector functions to choose variables.
For \code{step_nest}, this indicates the variables which will \emph{not} be nested.
See \code{\link[recipes:selections]{recipes::selections()}} for more details.}

\item{role}{Not used by this step since the new variables are assigned a
custom role.}

\item{trained}{A logical to indicate if the quantities for
preprocessing have been estimated.}

\item{skip}{A logical. Should the step be skipped when the
recipe is baked by \code{\link[=bake]{bake()}}? While all operations are baked
when \code{\link[=prep]{prep()}} is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using \code{skip = TRUE} as it may affect
the computations for subsequent operations.}

\item{id}{A character string that is unique to this step to identify it.}
}
\value{
An updated version of recipe with the new step added to the
sequence of any existing operations.
}
\description{
\code{step_nest} creates a \emph{specification} of a recipe step that will transform
data using \code{\link[tidyr:nest]{tidyr::nest()}}
}
\details{
Both the columns to nest and the outer columns must be included in the
recipe spec.
\code{step_nest} will give the non-nested columns a new role: 'nested_id'.
This should not be altered.
The actual transformation applied to the data resembles the following:
\code{tidyr::nest(data, data = c(...))}
This means that you can specify columns to nest in the traditional \code{c(cols)}
way, or by not wrapping the columns in c(), since the function does it
automatically.

If you nest the data yourself, the resulting nested column must be named
'data'.
For this reason, you must not have a column named 'data' in your inputted
data.
If you plan to use \code{\link[recipes:prep]{recipes::prep()}} and \code{\link[recipes:bake]{recipes::bake()}} on your recipe,
make sure your \code{step_nest} step is last, since other recipe steps will not
be able to evaluate on nested data.
}
\examples{
data("example_nested_data")

recipe <- recipes::recipe(example_nested_data, z ~ x + id) \%>\%
  step_nest(-id) # equivalent to tidyr::nest(example_nested_data, data = -id)

data <- recipe \%>\%
  recipes::prep() \%>\%
  recipes::bake(NULL)

recipe2 <- recipes::recipe(example_nested_data, z ~ x + id) \%>\%
  step_nest(x, z) 
# equivalent to tidyr::nest(example_nested_data, data = c(x,z))

data2 <- recipe \%>\%
  recipes::prep() \%>\%
  recipes::bake(NULL)
  
identical(data1, data2) # TRUE

}
